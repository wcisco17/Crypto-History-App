function asyncGeneratorStep(gen,resolve,reject,_next,_throw,key,arg){try{var info=gen[key](arg);var value=info.value}catch(error){reject(error);return}if(info.done){resolve(value)}else{Promise.resolve(value).then(_next,_throw)}}function _asyncToGenerator(fn){return function(){var self=this,args=arguments;return new Promise(function(resolve,reject){var gen=fn.apply(self,args);function _next(value){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"next",value)}function _throw(err){asyncGeneratorStep(gen,resolve,reject,_next,_throw,"throw",err)}_next(undefined)})}}import regeneratorRuntime from"regenerator-runtime";import{PutItemCommand}from'@crypto-aws/client';import{getHistoricalCoinAPIData,getHistoricalCryptoCompareOHLCVData}from'@crypto-api/db';export function createNumerical(_){return _createNumerical.apply(this,arguments)}function _createNumerical(){_createNumerical=_asyncToGenerator(regeneratorRuntime.mark(function _callee1(param){var client,coinName,coinapi,coinCompare,limit,time,hour,convertTime,ref,ref1,orderbooks,ohlcvCryptoCompare;return regeneratorRuntime.wrap(function _callee$(_ctx1){while(1)switch(_ctx1.prev=_ctx1.next){case 0:client=param.client,coinName=param.coinName,coinapi=param.coinapi,coinCompare=param.coinCompare,limit=param.limit,time=param.time,hour=param.hour,convertTime=param.convertTime;_ctx1.next=4;return getHistoricalCoinAPIData({limit:limit,time_start:time,time_end:'',symbol:{coinapi:coinapi},historical:'quotes'});case 4:orderbooks=_ctx1.sent;if(!(((ref=orderbooks.error)===null||ref===void 0?void 0:ref.length)>=1)){_ctx1.next=9;break}throw Error("[orderbooks] ".concat(orderbooks.error));case 9:orderbooks.map(function(){var _ref=_asyncToGenerator(regeneratorRuntime.mark(function _callee(orderbook){return regeneratorRuntime.wrap(function _callee$(_ctx){while(1)switch(_ctx.prev=_ctx.next){case 0:_ctx.next=2;return client.send(new PutItemCommand({TableName:'CryptoOrderBooks',Item:{CryptoSymbolID:{S:coinName},PriceTimeStamp:{N:convertTime.toString()},BidSize:{N:orderbook.bid_size.toString()},BidPrice:{N:orderbook.bid_price.toString()},AsksSize:{N:orderbook.ask_size.toString()},AsksPrice:{N:orderbook.ask_price.toString()},DataType:{S:'orderbooks'}}}));case 2:case"end":return _ctx.stop()}},_callee)}));return function(orderbook){return _ref.apply(this,arguments)}}());case 10:_ctx1.next=12;return getHistoricalCryptoCompareOHLCVData({limit:limit,time_start:convertTime.toString(),symbol:{coinCompare:coinCompare}});case 12:ohlcvCryptoCompare=_ctx1.sent;if(!((ohlcvCryptoCompare===null||ohlcvCryptoCompare===void 0?void 0:(ref1=ohlcvCryptoCompare.Message)===null||ref1===void 0?void 0:ref1.length)>=1)){_ctx1.next=17;break}throw new Error("[ohlcvCryptoCompare] ".concat(ohlcvCryptoCompare===null||ohlcvCryptoCompare===void 0?void 0:ohlcvCryptoCompare.Message));case 17:{ohlcvCryptoCompare.Data.map(function(){var _ref=_asyncToGenerator(regeneratorRuntime.mark(function _callee(coin){return regeneratorRuntime.wrap(function _callee$(_ctx){while(1)switch(_ctx.prev=_ctx.next){case 0:_ctx.next=2;return client.send(new PutItemCommand({TableName:'CryptoPrices',Item:{CryptoSymbolID:{S:coinName},PriceTimeStamp:{N:convertTime.toString()},TimeStamp:{N:coin.time.toString()},Close:{N:coin.close.toString()},High:{N:coin.high.toString()},Low:{N:coin.low.toString()},Open:{N:coin.open.toString()},DataType:{S:'ohlcv'}}}));case 2:case"end":return _ctx.stop()}},_callee)}));return function(coin){return _ref.apply(this,arguments)}}())}case 18:case"end":return _ctx1.stop()}},_callee1)}));return _createNumerical.apply(this,arguments)}